<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_boggle_right</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_warper</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>target_x = x;
target_y = y;

alarminprogress = false;
movementinprogress = false;

min_interval = 2;
max_interval = 6;

movement_speed = 1;

sprite = "boggle";
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Based on the instructed direction, the npc's target will be set
if(direction == 0 &amp;&amp; (position_meeting(x+8,(y-16)+8, obj_test_npc)==false)){
    target_y = y-16;
}
if(direction == 1 &amp;&amp; (position_meeting((x+16)+8,y+8, obj_test_npc)==false)){
    target_x = x+16;
}
if(direction == 2 &amp;&amp; (position_meeting(x+8,(y+16)+8, obj_test_npc)==false)){
    target_y = y+16;
}
if(direction == 3 &amp;&amp; (position_meeting((x-16)+8,y+8, obj_test_npc)==false)){
    target_x = x-16;
}


alarminprogress = false;
movementinprogress = true; //Prevents the npc from changing direction mid-movement
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (alarminprogress == false &amp;&amp; movementinprogress == false){
    direction = irandom_range(0,3); //Determines which direction the npc will travel next
    alarm[0] = random_range(min_interval*60, max_interval*60); //Sets a random time before the npc moves
    alarminprogress = true; //Prevents the npc from constantly moving
}

//Controls the npc movement
if((position_meeting(target_x+8,target_y+8, obj_solid)==false) &amp;&amp; (position_meeting(target_x+8,target_y+8, obj_npc_solid)==false) &amp;&amp; (position_meeting(target_x+8,target_y+8, obj_warper)==false)){
    if (x&lt;target_x){
        x += movement_speed;
        sprite_index = asset_get_index("spr_" + sprite + "_right");
        //sprite_index = asset_get_index(sprite);
    }
    if (x&gt;target_x){
        x -= movement_speed;
        sprite_index = asset_get_index("spr_" + sprite + "_left");
        //sprite_index = asset_get_index(sprite);
    }
    if (y&lt;target_y){
        y += movement_speed;
    }
    if (y&gt;target_y){
        y -= movement_speed;
    }
}else{
    target_x = round(x/16)*16;
    target_y = round(y/16)*16;
}

if (target_x == x &amp;&amp; target_y == y){
    movementinprogress = false;
}

//Determines which layer the npc appears on based on the player's location
//if (obj_player.y &gt; y) {
//    depth = 1;
//}else{
//    depth = -1;
//}

//Determines which layer the npc appears on based on its y value
depth = round(y/16) * -1;



</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
